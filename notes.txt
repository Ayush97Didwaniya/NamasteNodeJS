node REPL
read evaluate print loop
---------------------------------
node -> javascript runtime env

webworker - self, nodejs - global, browsers - window, frames - 
pointing to same global object

in 2020 open JS foundation come with the name globalThis
(after version 71)
----------------------------------------------------
Common JS Modules (CJS) =>
modules.exports 
required()
By default used in node
older Way
-> Synchronous way
-> Non strict mode

ES Modules(mjs) (ESM) =>
-> import 
exports
-> By default used in React, angular
-> Newer way
-> Async option 
-> strict mode
----------------------------------------------------


IIFE->immediately invoked function expression
node js wrapped the modules before sending it to v8 engine
in the form of IIFE
-> privacy - keep variable and functions safe 

(function () {})();

-> question asked: how are variables and function private in different module?
Answers is IIFE And require

------------------------------------------------------------------
-> how do you get access to module.exports
answers - nodeJs is passes module as a parameter to the IIFE

function (module, require, ...otherParams ) {
     require("path")

     function calculateMultiply(a, b) {
        return a * b;
     }

     module.exports = {calculateMultiply}
    All the code of the module is wrapped inside a function(IIFE)
}

&&&&&&&

### require(/path)
1. resolving the module
     -> ./localpath
     -> .json ->node:module

2. loading the module 
    -> File content is loaded according to file type
    
3. wraps inside IIFE -> compile 
4. Evaluation -> code is executed and returns module.exports
5. caching -> then the module is cached
it helps when multiple file required multiple same module
like import of one file into many, the code of the require runs only once.


--------------------------------------------------------------------
Node: Event driven architecture capable of async I/o
-----------------------------------------------------------------------

Libuv-> offloads async task(Super power to conncet to file, db, www, timer & more)
and return response to JS engine

library that ASync IO made simple (ITs a C program)
----------------------------------------------------------------------
JAVA script talks to libuv and libuv talks to OS
C language is very efficient to connect to OS

JS is a highlevel code and to connect with OS you need low level language
for which c we used here


Libuv acts as middle layer between js engine and OS

-------------------------------------------------------------------------
v8 engine creates global execution context inside calls stack while executing the code.

also offloads async tasks to libuv with callback function
once the async call gets completed, then the callback is executed inside callstack of v8 engine

garbage collector removes the variable from memory heap if it doesnt get used.

-------------------------------------------------------------------------
Async task inside (libuv) are not blocking the main thread inside v8 callstack
----------------------------------------------------------------------------------

Require("") -> works in synch way and import work in async

----------------------------------------------------------------------------------
fs.readFileSync will block the main thread


----------------------------------------------------------------------------------
const crypto = require("node:crypto");
// core nodeJs module 
// optional to add node:

----------------------------------------------------------------------------------
// Once the callstack is empty then only libuv callback functions can be executed even if
settimeout is zero.

settimeout time counted after callstack gets empty

----------------------------------------------------------------------------------
V8 Engine working: (other js engine doesnt works the same way) (2017)

Code -> v8 Engine
A. Parsing
1. Lexical Analysis (tokanization)
code -> Tokens
2. Syntax Analysis (Parsing)
Tokens -> node (AST) ==== tokens are converted into ast
WEbsite famouse for ast -> astexplorer.net


B. Interpretter/Compiler:
v8 engines has compiler and interpretter both available
(JIT compiler - just in time compiler)

- Interpretter
AST -> Interpretter (Ignitation Interpretter)
Interpretter -> Byte code // Interpretter converts the ast into byte code
byte code -> execution // byte code gets executed

Interpretter identifies peace of code that is executed again and again
then ignitaition interpretter give that code to compiler
so then whenever it runs again, it runs Fast (the code, which is given to compielr called HOT code)
                 
                       HOT code
Ignitation interpretter -> Turbofan compiler (this process is called optimation also)

- Compiler(Turbo fan compiler)
compiler -> optimised to machine code
machine code-> execution


- Earlier to turbo fan, crankshaft compiler been used.

- Sometime the code is deoptimised -> 
while optimizing the code turbo fan compiler makes assumption

- for ex:
suppose hot code -> sum(10, 5)
next time sum(2,3)
next sum(6,5)
then when user calls the fn with string param
sum("a", "b") - here the optimization failed
here it will deoptimized the code

- Also inline caching and copy elision happens in igniation interpretter

the entire above process called JIT

c. Garbage collection - (Mark and sweep algo)
1. orinaco
2. oil Pan
3. Scavenger
4. mcompact
----------------------------------------------------------------------------------
Two types of languages:
1. Interpretted:
- Line by line execution
- Fast Initial Execution
- Interpretter
2. Compiled:
- First compilation (HL code -> machine code)
then the machine code is executed.
- Initially heavily, but after compilation it executed Fast
- Compilers
----------------------------------------------------------------------------------
Libuv - Event loop

Event loop can send event to v8 engine callstack when it is idle, or main thread is not busy.

Event loop does wait in the poll phase (in node)
in browser it keeps running
----------------------------------------------------------------------------------

One cycle of eventloop called one tick

whatever pending callbacks executes before poll phase in eventloop, in the next loop iteration


idle, prepare checks handle internally

-----------------E-----------------------------------------------------------------
Thread pool used for only:
fs
dns.lookup
crypt.pbkdf
user specified input

, API doesnt use the threadpool

----------------------------------------------------------------------------------
OS:   connects to
LIBUV <--------> epoll (Linux)(Red-black tree), kqueue (MacOS)
[Scalable I/O event notification mechanism] at os kernal level
OS -> kernal -> processes

Every user request needs one socket to connect
Its not a good practice to have multiple sockets for multiple connections at once
so epoll manages that.


epoll descriptor is a collection of your socket descriptor
socket descriptor also call fds - file descriptor

One epoll descriptor can manage multiple connection

Libuv uses epoll
As soon as any activity happens on connection then it notifies libuv and then
libuv will take care of it using event loop and then it executes in v8 engine.
----------------------------------------------------------------------------------
Event emitter
stream & buffer
pipes
----------------------------------------------------------------------------------
settimeout queue uses minheap data structure in callstack. 
----------------------------------------------------------------------------------

Express is a framwork to create http server which can handle the incoming requests.


----------------------------------------------------------------------------------
Database:
Database is an organized collection of data.

RDBMS = mysql, postgresSql

SQL:
EF codd - codd's 12 rules [0-12]
RDB - Relational db

MYSQL -
michal wedenius -> MY -> mysql (sum microsystem later acquired oracle), max, maria

michael stonebraker
Ingres (v. of california)
later come to university again and worked on sql-> post Ingres


NOSQL (mongodb): Not only sql
- document db
- key value db
- graph db
- wide column db
- multimodel db

mongo db is a document db.
---------------------------------------------------------------------------------
RDBMS (Mysql)
- table, rows, columns
- structured data
- fixed schema
- sql 
- Tough horizontal scaling
- Relationships - foreign keys + joins
- Read Heavy apps,
transaction workloads
- Ex. banking apps.

Nosql(mongodb):
- collection, document, fields
- unstructured Data
- Flexible schema
- mongodb(mQL), neo4J(cypher)
- Easy to scale horizontal and vertically
- Nested Relationships
- Real Time , big data, distributed computing
- ex.: real time analytics, social media


----------------------------------------------------------------------------------
NPM: is a repository which contains lots of node module packages
 

----------------------------------------------------------------------------------


----------------------------------------------------------------------------------

